ATOMIC 연산 (Atomic Operation)
============

이번에 정리할 내용은 Atomic 연산(Atomic Operation)에 대한 내용입니다. 

SW를 싱글 쓰레드로만 구현한 경우에는 신경을 쓸 필요가 없지만, 멀티쓰레드를 사용하는 경우에는 락 (Mutex, SpinLock 등) 만큼 중요한 것이 이번에 설명할 atomic 연산이라고 할 수 있습니다.

일단 왜 Atomic 연산에 대한 고려가 멀티쓰레드에서 중요한 것인지를 이해하기 위해서는 CPU에서 SW의 연산에 사용되는 데이타가 어떻게 관리되는지를 먼저 이해할 필요가 있습니다.

## CPU의 데이타 저장소 (레지스터 / 캐시 / 메모리) 
--------

우리가 작성한 SW는 일반적으로 영구 저장 장치 (HDD, Flash 등)에 저장되어 있으며, SW의 수행이 필요한 시점에 주 메모리 (DDR, SDRAM, SRAM 등)에 로딩되며 SW에 의해 연산/생성/참조되는 데이타들 역시 기본적으로는 모두 주 메모리안에 저장된다는 된다는 것은 알고 계실 겁니다.

어셈블러를 사용하는 경우를 제외하고 일반적인 SW를 구현할 때 SW에게는  주 메모리 (또는 디스크등) 만 보이지만 CPU와 주 메모리 사이에는 아래와 같이 추가적인 데이타 공간이 존재하고 있습니다. 

```
+-------------------------------------------------------+
|                       CPU Chip                        | 
|  +-----------------------------------+  +------+      |
|  |               Core                |  | Core |      |
|  | +--------------+ +--------------+ |  |      |      |
|  | | Hyper Thread | | Hyper Thread | |  |      |      |
|  | | +----------+ | | +----------+ | |  |      |      |
|  | | | Register | | | | Register | | |  |      |      |
|  | | +----------+ | | +----------+ | |  |      |      |
|  | +-------+------+ +------+-------+ |  |      | .... |
|  |         |               |         |  |      |      |
|  |    +----+---------------+----+    |  |      |      |
|  |    |        L1 Cache         |    |  |      |      |
|  |    +------------+------------+    |  |      |      |
|  |                 |                 |  |      |      |
|  +-----------------+-----------------+  +--+---+      |
|                    |                       |          |
|  +-----------------+-----------------+  +--+---+      |
|  |             L2 Cache              |  |  L2  |      |
|  +-----------------+-----------------+  +--+---+      |
|                    |                       |          |
|  +-----------------+-----------------------+--------+ |
|  |                    L3 Cahcel                     | |
|  +--------------------------------------------------+ |
+-------------------------------------------------------+
```

> 레지스터 (Register) 
> - CPU 내부에 있는 저장 공간으로 모든 CPU가 가지고 있습니다.
> - 레지스테는 CPU가 처리하는 모든 종류의 연산에 사용되는 데이타 값을 보관하는 Data Register류, 참조에 필요한 메모리 주소를 저장하는 Address Register류, 연산의 결과를 보관하기 위한 Arithmetic Register류 등으로 구분되며 수백 바이트 용량 (수십개의 레지스터)을 일반적으로 가지고 있습니다. 
 
> L1/L2/L3 Cache
> - CPU 내부/외부에 있는 저장 공간으로 (거의) 모든 CPU가 가지고 있습니다.
> - Cache는 CPU와 주 메모리 간의 데이타 Read/Write 에 대한 임시 저장 공간(캐시) 역할을 수행합니다. 
> - 상기 캐시의 구조는 논리적인 계위를 보여주는 것이고 실제적인 물리적 구성은 CPU별로 다를 수 있습니다. 


## 사칙 연산의 동시성 
-----

이제 SW에서 아래와 같이 단순한 기능을 수행하는 코드가 실제 CPU에서 어떻게 수행되는 지 알아보도록 하겠습니다. 

```cpp
int value;      // 전역 변수
int my_func() {
    value += 1;
    return value;
}

```
위의 함수를 컴파일한 후 CPU에서 실제 수행하는 어셈블러 코드로 역변환(Disassembly)을 하면 아래와 같은 어셈블러 코드가 생성됩니다.


```cpp
int my_func()
{
  push   rbp
  mov    rbp,rsp                        
    value += 1;
  mov    eax,DWORD PTR [rip+0x200b54]   // #1, value를 레지스터로 복사 
  add    eax,0x1                        // #2, eax 레지스터의 값을 증가
  mov    DWORD PTR [rip+0x200b4b],eax   // #3, 레지스터 값을 메모리로 복사 
  
    return value;
  mov    eax,DWORD PTR [rip+0x200b45]
}
  pop    rbp
  ret

```

위의 소스에서 C 코드로 표현된 부분의 아래쪽에 위치한 어셈블러가 해당 C 코드에 대한 어셈블러 코드라고 보면 되고, *"value += 1"* 을 수행하기 위해 *"#1 ~ #3*" 까지의 세개의 어셈블리 코드가 수행됨을 알 수 있습니다.

코드 옆에 주석을 달아놓은 것처럼 하나의 변수를 중가하기 위해 CPU는 *"메모리내 데이타의 복사" -> "Register만을 이용한 데이타의 덧셈" --> "메모리로 연산 결과를 복사"* 하는 과정을 수행합니다. 


## 조건문의 동시성 
-----

이번에는 *"if (비교)"* 에를 한번 보도록 하겠습니다. 

```cpp
void my_func()
{
  push   rbp
  mov    rbp,rsp
    if (value == 0) {   value = 1;  }
  mov    eax,DWORD PTR [rip+0x200b54] // #1, value를 Register로 복사 
  test   eax,eax                      // #2, value - value 연산 수행 
  jne    4004f0 <my_func+0x1a>        // #3, "연산결과 != 0"이면 #6로 점프  
  mov    DWORD PTR [rip+0x200b46],0x1 // #4, value에 1을 저장 
    else            {   value = 0;  }
  jmp    4004fa <my_func+0x24>        // #5, #6으로 점프 
  mov    DWORD PTR [rip+0x200b3a],0x0 // #6, value에 0을 저장 
  pop    rbp                          // #7
  ret
```

위의 코드는 value란 전역변수를 0과 1 사이에서 토글시키는 간단한 함수입니다. 
이 예제 역시 *"if (value == 0)"*이란 비교를 수행하기 위해 *"#1 ~ #3"* 까지의 세개의 어셈블리 코드가 수행됨을 알 수 있습니다.

코드 옆에 주석을 달아놓은 것처럼 하나의 변수값을 비교하는 과정도 첫번째 예처럼 CPU 입장에서는 뺄셈을 하는 것과 다를 게 없이 
*"메모리 데이타의 로딩" -> "레지스터만을 이용한 데이타의 뺄셈" -> "연산 결과가 0인지 아닌지의 비교"* 하는 다수의 단계를 수행하게 됩니다. 

> CPU에서 값의 비교란 *"메모리 데이타 == 상수"* 와 같은 직접적인 비교는 할 수 없고 *"사칙 연산의 수행 결과 == zero or not"* 만을 판단할 수 있기 때문에 위와 같은 수행 절차를 거치게 됩니다.

그럼 왜 CPU는 모든 연산을 메모리를 직접 이용하지 않고 Register란 중간 저장소를 이용하고 위와 같은 문제를 발생시키게 된 걸까요 ?  

* Register는 메모리 또는 캐시에 비해 CPU의 제어 로직이 접근하는   속도가 월등히 빠릅니다. (Register의 접근 속도 = CPU의 성능)
* 하나의 연산 결과는 연이은 또다른 연산에 재사용될 가능성이 상당히 높기 때문에 연산 결과를 Register 내에 보관하고 있는 것이 성능 개선에 유리합니다.
* 메모리는 단순한 저장장치로 연산을 수행할 수도 없고, 특정 데이타를 다른 영역으로 직접 복사/이동시킬 수도 없습니다.
* 연산 메모리가 연산 장치를 가진다면 CPU라고 부르는 게 맞고 실제 최근의 CPU들은 내부 공간의 절반 정도는 메모리 (Cache)를 만들기 위한 공간으로 사용합니다.


## ATOMIC 연산의 필요성   
-----

이러한 연산/비교를 수행하기 위한 코드가 멀티쓰레드에서 발생시키는 문제는

* *value* 가 전역변수이므로 모든 쓰레드가 접근을 할 수 있고
* CPU 역시 다수의 Core를 가지고 있고 Core별로 각각의 독립적인 Register를 가지고 있기 때문에 (Intel의 경우는 HT별로 1벌씩)

첫번째 예에서 만약 4개의 Core가 동시에 *"value = 0"* 에 대해 *"value += 1"* 절차를 수행한다면 4번의 연산이 수행되므로 *"value +=4"* 가 되어야 하겠지만 *"#1 ~ #3*" 과정이 동시에 수행되고, *#2* 에서 Register는 모두 0이라는 값을 가지고 덧셈을 수행하므로 결론적으로 *"value += 1"* 인 결과가 나타납니다.물론 위의 상황외에도 A라는 쓰레드가 #2를 실행중인데 B 라는 쓰레드가 #1을 수행하는 경우, A는 #3를 수행하는 데 B는 #1 또는 #2를 수행하는 경우 등 더 많은 상황이 있을 수 있습니다. 

두번째 예에서는 *"#1 ~ #3"* 까지는 다수의 Core가 동시에 수행해도 문제가 없지만 (메모리에 대한 Read Only 참조) 곧이어 참조한 변수를 바꾸는 *"#4, #6"* 과정이 있기 때문에 다수의 Core가 (거의) 동시에 수행을 하게 되면 *"#1 ~ #3"*을 수행하는 과정에 *"#4, #6"*이 동시에 수행될 수 있기 때문에 최종적으로 "value"의 값이  어떻게 될 것인지 알 수 없습니다.

그러므로 멀티쓰레드 환경에서는 이러한 연산을 **안전하게** 할 수 있는 방법이 필요하게 되고, 소프트웨어적으로 해결할 수 있는 한계가 분명하기 때문에 **제한적인 범위의 ATOMIC 연산**을 하드웨어에서 제공합니다.  

Atomic 연산이 
* x86의 경우 1개의 메모리 영역에 대해 연산 시 CPU의 메모리 억세스 전체를 중지시키는 형태로 제공 (LOCK  Prefix ) 


## ATOMIC 연산의 특징 
-----

GCC를 사용하게 되면 GCC에서 제공하는 built-in ATOMIC 연산과 관된 함수들을 *"__sync_..."* 형태의 함수들을 통해 제공합니다. 

> Case-A) 첫번째 예와 같은 경우를 위한 ATOMIC 연산 함수 
> * 변수에 대한 연산을 수행하고 연산 수행 전의 값을 반환
> * 변수에 대한 연산을 수행하고 연산 수행 후의 값을 반환

> Case-B) 두번째 예와 같은 경우를 위한 ATOMIC 연산 함수 
> * 변수가 A와 같으면 B라는 값으로 변경 

일단 ATOMIC 연산의 특징이라고 할 수 있는 것은 
* 지원되는 연산의 종류가 +, -, AND, OR, XOR, NAND로 제한
* 사용 가능한 변수의 종류는 1, 2, 4, 8 바이트 정수형만 가능
* 변경될 수 있는 변수는 1개만 가능

이라고 할 수 있고 GCC built-in 에서는 Atomic 연산의 대상 데이타의 크기 (1, 2, 4, 8 바이트등)에 대한 제한을 두고 있진 않지만 실제로 다양한 CPU에 모두 적용을 고려해야 한다면 소프트웨어에서 사용하는 Atomic 변수의 크기는 4 바이트 (int, unsigned int) 또는 8 바이트 (int64_t, uint64_t, CPU가 64비트인 경우) 정도로만 사용할 필요가 있습니다.



x86의 경우에는 1 ~ 8 바이트 정수형에 대해 모두 Atomic 연산 기능을 제공하지만 CPU 마다 Atomic 연산 기능의 구현 방식이 틀리고 제한적이기 때문에 
모든 CPU 종류에 대해서 GCC가 built-in을 제공하지도 않기 때문에  








참고 
---------

ATOMIC 연산을 사용하지 않는 경우에 대한 연산 오류 예 

> 조건 
> - 쓰레드 2개를 구동하고 하나의 전역 변수에 대해서  
> - A 쓰레드는 *"value += 1"* 을 2억회 수행
> - B 쓰레드는 *"value -= 1"* 을 1억회 수행
> - 쓰레드가 모두 종료되면 전역 변수의 최종값을 출력 

> | 회차 |   1 | 2 | 3 | 4 | 5 | 
> | --- | --: | --: | --: | --: | --: | 
> | 결과 | 부정확 | 부정확 | 부정확 | 정확 | 정확 | 
> | 최종값 | 100477358 | 97968720 | 97968720 | 100000000 | 100000000





상기 예에 언급한 어셈블러 코드를 생성하는 방법 

> C 소스 컴파일하는 방법 : gcc -g -o sample sample.c 
> - -g : 실행파일내에 디버깅 정보를 추가합니다. 이 정보를 이용하여  Disassembly 시 어셈블리 코드내에 C 코드 참조 위치를 표시할 수 있습니다. 
> - -o : 컴파일된 실행 파일명을 지정합니다. 위 예에서는 *sample*이 실행파일입니다.
> - -Ox 계열의 최적화 옵션을 주게 되면 최적화로 인해 C 코드 참조 위치가 부정확하게 나옵니다. 
 

> Disassembly 생성 방법 : objdump -S -d -M intel-Mnemonic out 
> - -S : 생성된 어셈블러 코드내에 참조용 원본 C 코드를 추가합니다. 단 확장자를 제외한 실행파일명과 소스 파일명이 같아야 합니다.  
> - -d :objdump 프로그램에게 Disassembly 를 요청합니다.  
> - -M intel-Mnemonic : 어셈블러 코드를 인텔 어셈블러 형태로 출력합니다. 


Links 
---------

* https://en.wikipedia.org/wiki/CPU_cache
* https://en.wikipedia.org/wiki/Scratchpad_memory
* https://www.nextplatform.com/2016/05/31/intel-lines-thunderx-arms-xeons/

* http://demin.ws/blog/english/2012/05/05/atomic-spinlock-mutex/